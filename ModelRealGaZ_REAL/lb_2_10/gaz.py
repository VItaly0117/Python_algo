from vpython import *  # Імпортуємо бібліотеку vpython для створення 3D-анімації та графіків
from random import \
    random  # Імпортуємо функцію random (для сумісності зі старим кодом), хоча основну роботу робить numpy
import \
    numpy as np  # Завдання 2.1: Підключаємо бібліотеку NumPy, щоб працювати з масивами (це набагато швидше, ніж звичайні списки)

# --- Блок констант та фізичних параметрів ---
kB = 1.38e-23  # Стала Больцмана (потрібна для термодинамічних розрахунків)
n = 40  # Кількість частинок (атомів) у нашій системі (збільшили для 3D)
T = 50  # Температура системи в Кельвінах
m = 6.65e-26  # Маса одного атома аргону (в кілограмах)
r0 = 3.4e-10  # Параметр r0 потенціалу Леннарда-Джонса (ефективний розмір атома)
sigma = 119 * kB  # Глибина потенціальної ями (енергетичний параметр взаємодії)
R = r0 / 2  # Радіус кульки для візуалізації (половина від r0)
lx = 1e-8  # Розмір коробки по осі X (ширина)
ly = 1e-8  # Розмір коробки по осі Y (висота)
lz = 1e-8  # Завдання 2.6: Розмір коробки по осі Z (глибина), щоб модель була тривимірною

t_global = 1e-9  # Загальний час моделювання (скільки секунд фізичного часу пройде)
dt = 1e-15  # Крок часу (скільки часу проходить за один розрахунковий цикл, дуже мале число!)

scale = 1 / lx  # Масштабний коефіцієнт, щоб переводити малі фізичні метри у зрозумілі координати екрану
scene1 = canvas(width=800, height=800, background=vector(0, 0, 0), center=vector(0.5, 0.5, 0.5),
                align='left')  # Створюємо вікно анімації: чорний фон, розмір 800х800, центр камери посередині куба

# Завдання 2.8 (Власні ідеї): Малюємо напівпрозорий куб, щоб бачити межі нашої "коробки"
box(pos=vector(0.5, 0.5, 0.5), length=1, height=1, width=1, opacity=0.1, color=color.white)

# --- Блок налаштування графіків ---
# Завдання 2.2: Створюємо поле для графіків з підписами осей та назвою
graph(title="Енергії системи", xtitle="Час (кроки)", ytitle="Енергія (Дж)", width=500, height=300,
      background=color.white, align="left", autoscale=True)
E_gen_graf = gcurve(label="Повна (Total)", color=color.black, width=2)  # Чорна лінія для повної енергії
Ek_graf = gcurve(label="Кінетична (Ek)", color=color.red, width=2)  # Червона лінія для кінетичної енергії
Ep_graf = gcurve(label="Потенціальна (Ep)", color=color.green, width=2)  # Зелена лінія для потенціальної енергії

# --- Ініціалізація масивів (Завдання 2.1) ---
# Створюємо пусті масиви з нулів розміром n. Це місця, куди ми запишемо координати та швидкості.
x = np.zeros(n)  # Координати X
y = np.zeros(n)  # Координати Y
z = np.zeros(n)  # Завдання 2.6: Координати Z для 3D
vx = np.zeros(n)  # Швидкість по X
vy = np.zeros(n)  # Швидкість по Y
vz = np.zeros(n)  # Завдання 2.6: Швидкість по Z
fx = np.zeros(n)  # Сила, що діє на частинку по X
fy = np.zeros(n)  # Сила по Y
fz = np.zeros(n)  # Завдання 2.6: Сила по Z
ball = []  # Список для зберігання графічних об'єктів (кульок vpython)


# --- Фізичні функції (Завдання 2.3: Оптимізація) ---
# Тут ми замінили повільні log() та exp() на швидке піднесення до степеня.
def p_func(r):
    # Рахує потенціальну енергію взаємодії двох частинок на відстані r
    # Формула Леннарда-Джонса: V = 4*sigma * ((r0/r)^12 - (r0/r)^6)
    r_rel = (r0 / r) ** 6  # Спочатку рахуємо (r0/r) у 6-му степені
    return 4 * sigma * (r_rel ** 2 - r_rel)  # Потім підносимо до квадрату, щоб отримати 12-й степінь


def f_func(r):
    # Рахує силу відштовхування/притягання між частинками
    # Це похідна від потенціалу по відстані
    r_rel = (r0 / r) ** 6
    return 24 * sigma / r * (2 * r_rel ** 2 - r_rel)


# --- Функція взаємодії зі стінками (Завдання 2.5) ---
def GB_wall(coor, vel_comp, limit):
    # Ця функція перевіряє, чи не вилетіла частинка за межі коробки.
    # coor - поточна координата, vel_comp - швидкість, limit - розмір коробки (lx, ly або lz)

    if coor < 0:  # Якщо координата менша за 0 (вилетіла вліво/вниз/назад)
        coor = -coor  # "Віддзеркалюємо" координату назад у коробку
        vel_comp = -vel_comp  # Змінюємо знак швидкості (відскок від стінки)

    if coor > limit:  # Якщо координата більша за розмір коробки (вилетіла вправо/вверх/вперед)
        coor = 2 * limit - coor  # "Віддзеркалюємо" від дальньої стінки
        vel_comp = -vel_comp  # Змінюємо знак швидкості на протилежний

    return coor, vel_comp  # Повертаємо виправлену координату і нову швидкість


# --- Періодичні граничні умови ---
# Ця функція (BC) зараз не використовується в циклі, бо ми включили GB_wall,
# але вона була в оригіналі для реалізації "нескінченного" простору.
def BC(coor, limit):
    if coor < 0: coor += limit  # Якщо вилетів зліва, з'явись справа
    if coor > limit: coor -= limit  # Якщо вилетів справа, з'явись зліва
    return coor


# --- Функція ініціалізації системи ---
def init():
    # Завдання 2.4: Використовуємо бібліотеку numpy для розподілу Максвелла
    # Рахуємо теплову швидкість v_thermal = sqrt(kB * T / m)
    v_thermal = np.sqrt(kB * T / m)

    global vx, vy, vz  # Кажемо, що будемо змінювати глобальні масиви швидкостей
    # np.random.normal створює масив випадкових чисел з нормальним (Гаусовим) розподілом
    vx = np.random.normal(0, v_thermal, n)
    vy = np.random.normal(0, v_thermal, n)
    vz = np.random.normal(0, v_thermal, n)

    for i in range(n):
        # Завдання 2.7: Захист від накладання частинок (щоб не вибухнуло на старті)
        valid_position = False  # Прапорець: чи знайшли ми хороше місце? Поки ні.

        while not valid_position:  # Поки не знайдемо хороше місце, крутимо цикл
            # Генеруємо випадкові координати всередині коробки (з відступом R від стінок)
            candidate_x = R + (lx - 2 * R) * random()
            candidate_y = R + (ly - 2 * R) * random()
            candidate_z = R + (lz - 2 * R) * random()

            # Перевіряємо відстань до всіх вже створених частинок (від 0 до i-1)
            too_close = False  # Припускаємо, що ніхто не заважає
            for j in range(i):
                # Рахуємо відстань між кандидатом і існуючою частинкою j
                dist = sqrt((candidate_x - x[j]) ** 2 + (candidate_y - y[j]) ** 2 + (candidate_z - z[j]) ** 2)
                if dist < 0.9 * r0:  # Якщо відстань менша за розмір атома...
                    too_close = True  # ...то це занадто близько!
                    break  # Перериваємо перевірку, бо вже погано

            if not too_close:  # Якщо ні з ким не перетнулися
                x[i] = candidate_x  # Записуємо координати в масив
                y[i] = candidate_y
                z[i] = candidate_z
                valid_position = True  # Ставимо прапорець, що все ок, виходимо з while

        # Створюємо 3D-сферу для цієї частинки і додаємо її в список ball
        ball.append(sphere(pos=vector(x[i] * scale, y[i] * scale, z[i] * scale), radius=R * scale,
                           color=vector(1 - i / n, i / n, 1), make_trail=False))


# --- Запуск ініціалізації ---
init()  # Викликаємо функцію, яку щойно написали
t = 0  # Початковий час
step_count = 0  # Лічильник кроків (для графіків)

# Кількість фізичних розрахунків на один кадр анімації.
# Збільшили до 100, щоб анімація не виглядала "замороженою", бо dt дуже малий.
steps_per_frame = 100

# --- Головний цикл програми ---
while t < t_global:  # Поки не досягнемо кінцевого часу моделювання
    rate(30)  # Обмежуємо анімацію до 30 кадрів на секунду

    # Робимо серію швидких розрахунків фізики без малювання (для прискорення)
    for _ in range(steps_per_frame):
        if t >= t_global: break  # Додаткова перевірка виходу з циклу

        Ep = 0  # Обнуляємо лічильник потенціальної енергії для цього кроку

        # Очищаємо масиви сил, щоб старі сили не впливали на новий крок
        fx[:] = 0
        fy[:] = 0
        fz[:] = 0

        # --- Розрахунок сил взаємодії між усіма парами частинок ---
        for i in range(n):
            for j in range(i + 1, n):  # Оптимізація: j починаємо з i+1, щоб кожну пару (i,j) рахувати 1 раз

                # Рахуємо відстань по осях (проекції вектора відстані)
                dx = x[i] - x[j]
                dy = y[i] - y[j]
                dz = z[i] - z[j]

                # ТУТ МИ НЕ ВИКОРИСТОВУЄМО ПЕРІОДИЧНІСТЬ, бо у нас тверді стінки (GB_wall).
                # Просто теорема Піфагора для відстані в 3D.
                r = sqrt(dx ** 2 + dy ** 2 + dz ** 2)

                if r < r0 * 3:  # "Cutoff" - якщо частинки дуже далеко (>3 r0), силою нехтуємо для швидкості
                    f = f_func(r)  # Рахуємо величину сили
                    p = p_func(r)  # Рахуємо енергію взаємодії

                    # Проектуємо силу на осі X, Y, Z
                    ForceX = f / r * dx
                    ForceY = f / r * dy
                    ForceZ = f / r * dz

                    # 3-й закон Ньютона: сила діє на обидві частинки, але в різні боки
                    fx[i] += ForceX;
                    fx[j] -= ForceX
                    fy[i] += ForceY;
                    fy[j] -= ForceY
                    fz[i] += ForceZ;
                    fz[j] -= ForceZ

                    Ep += p  # Додаємо потенціальну енергію цієї пари до загальної суми

        Ek = 0  # Обнуляємо кінетичну енергію

        # --- Рух частинок (Другий закон Ньютона) ---
        for i in range(n):
            # Змінюємо швидкість: v = v0 + (F/m)*dt
            vx[i] = vx[i] + fx[i] / m * dt
            vy[i] = vy[i] + fy[i] / m * dt
            vz[i] = vz[i] + fz[i] / m * dt

            # Змінюємо координати: x = x0 + v*dt
            # І одразу викликаємо GB_wall, щоб перевірити відбивання від стінок
            x[i], vx[i] = GB_wall(x[i] + vx[i] * dt, vx[i], lx)
            y[i], vy[i] = GB_wall(y[i] + vy[i] * dt, vy[i], ly)
            z[i], vz[i] = GB_wall(z[i] + vz[i] * dt, vz[i], lz)

            # Рахуємо квадрат швидкості для кінетичної енергії
            v2 = vx[i] ** 2 + vy[i] ** 2 + vz[i] ** 2
            Ek += m * v2 / 2  # Додаємо (m*v^2)/2 до загальної Ek

        # --- Термостат (контроль температури) ---
        # Цей блок штучно підганяє швидкості, щоб температура трималася біля T = 50K
        # Коефіцієнт масштабування = sqrt(потрібна енергія / поточна енергія)
        norma = sqrt((3 / 2 * n * kB * T) / Ek)  # 3/2 kT - формула середньої енергії для 3D газу
        vx *= norma  # Множимо всі швидкості на коефіцієнт
        vy *= norma
        vz *= norma
        Ek *= norma ** 2  # Оновлюємо значення кінетичної енергії після масштабування

        t = t + dt  # Збільшуємо фізичний час
        step_count += 1  # Лічильник кроків +1

    # --- Блок візуалізації (виконується 1 раз на steps_per_frame кроків) ---
    for i in range(n):
        # Оновлюємо позиції кульок на екрані згідно з новими координатами
        ball[i].pos = vector(x[i] * scale, y[i] * scale, z[i] * scale)

    E_total = Ek + Ep  # Повна енергія = Кінетична + Потенціальна

    # Малюємо точки на графіку
    # Ділимо на 1.6e-19, щоб перевести Джоулі в електрон-вольти (так зручніше читати графік)
    Ek_graf.plot(t / dt, Ek / 1.6e-19)
    Ep_graf.plot(t / dt, Ep / 1.6e-19)
    E_gen_graf.plot(t / dt, E_total / 1.6e-19)